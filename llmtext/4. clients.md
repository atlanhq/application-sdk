# Application SDK Clients Documentation

This document provides comprehensive documentation for the Application SDK's clients module, which implements client interfaces for various external services.

## Table of Contents
1. [Base Client Interface](#base-client-interface)
2. [SQL Client](#sql-client)
3. [Temporal Client](#temporal-client)
4. [Constants](#constants)

## Base Client Interface

### ClientInterface
Abstract base class for implementing client connections.

**Methods:**
- `load() -> None`: Abstract method for establishing client connection
- `close() -> None`: Method for closing client connection (default implementation does nothing)

## SQL Client

### SQLConstants
Constants for SQL client configuration.

**Values:**
- `USE_SERVER_SIDE_CURSOR`: Boolean flag for server-side cursor usage (default: true)

### SQLClient
Base SQL client for database operations.

**Attributes:**
- `connection`: Database connection instance
- `engine`: SQLAlchemy engine instance
- `sql_alchemy_connect_args`: Additional connection arguments
- `credentials`: Database credentials
- `use_server_side_cursor`: Whether to use server-side cursors

**Methods:**
- `__init__(use_server_side_cursor=None, credentials=None, sql_alchemy_connect_args=None)`: Initialize client
- `load(credentials: Dict[str, Any]) -> None`: Establish database connection
- `close() -> None`: Close database connection
- `get_sqlalchemy_connection_string() -> str`: Get connection string (abstract)
- `run_query(query: str, batch_size: int = 100000)`: Run query in batch mode

### AsyncSQLClient
Asynchronous SQL client for database operations.

**Attributes:**
- `connection`: Async database connection instance
- `engine`: Async SQLAlchemy engine instance

**Methods:**
- `load(credentials: Dict[str, Any]) -> None`: Establish async connection
- `run_query(query: str, batch_size: int = 100000)`: Run query in async batch mode

## Temporal Client

### TemporalConstants
Constants for Temporal client configuration.

**Values:**
- `HOST`: Temporal server host (default: "localhost")
- `PORT`: Temporal server port (default: "7233")
- `NAMESPACE`: Temporal namespace (default: "default")
- `APPLICATION_NAME`: Application name (default: "default")
- `WORKFLOW_MAX_TIMEOUT_HOURS`: Maximum workflow timeout (default: 1 hour)

### Event Interceptors

#### EventActivityInboundInterceptor
Interceptor for tracking activity execution events.

**Methods:**
- `execute_activity(input: ExecuteActivityInput) -> Any`: Execute activity with event tracking

#### EventWorkflowInboundInterceptor
Interceptor for tracking workflow execution events.

**Methods:**
- `execute_workflow(input: ExecuteWorkflowInput) -> Any`: Execute workflow with event tracking

#### EventInterceptor
Temporal interceptor for event tracking.

**Methods:**
- `intercept_activity(next: ActivityInboundInterceptor) -> ActivityInboundInterceptor`: Intercept activity executions
- `workflow_interceptor_class(input: WorkflowInterceptorClassInput) -> Optional[Type[WorkflowInboundInterceptor]]`: Get workflow interceptor class

### TemporalClient
Client for interacting with Temporal workflow service.

**Attributes:**
- `client`: Temporal client instance
- `worker`: Temporal worker instance
- `application_name`: Name of the application
- `worker_task_queue`: Task queue for the worker
- `host`: Temporal server host
- `port`: Temporal server port
- `namespace`: Temporal namespace

**Methods:**
- `__init__(host=None, port=None, application_name=None, namespace="default")`: Initialize client
- `get_worker_task_queue() -> str`: Get worker task queue name
- `get_connection_string() -> str`: Get Temporal server connection string
- `get_namespace() -> str`: Get Temporal namespace
- `load() -> None`: Connect to Temporal server
- `close() -> None`: Close client connection
- `start_workflow(workflow_args: Dict[str, Any], workflow_class: Type[WorkflowInterface]) -> Dict[str, Any]`: Start workflow execution
- `stop_workflow(workflow_id: str, run_id: str) -> None`: Stop workflow execution
- `create_worker(activities: Sequence[CallableType], workflow_classes: Sequence[ClassType], passthrough_modules: Sequence[str], max_concurrent_activities: Optional[int] = None) -> Worker`: Create Temporal worker
- `get_workflow_run_status(workflow_id: str, run_id: Optional[str] = None, include_last_executed_run_id: bool = False) -> Dict[str, Any]`: Get workflow status

## Usage Examples

### SQL Client
```python
# Synchronous client
client = SQLClient(
    use_server_side_cursor=True,
    credentials={"host": "localhost", "port": 5432}
)
await client.load()
async for batch in client.run_query("SELECT * FROM table"):
    process_batch(batch)

# Asynchronous client
client = AsyncSQLClient(
    use_server_side_cursor=True,
    credentials={"host": "localhost", "port": 5432}
)
await client.load()
async for batch in client.run_query("SELECT * FROM table"):
    process_batch(batch)
```

### Temporal Client
```python
client = TemporalClient(
    host="localhost",
    port="7233",
    application_name="my-app"
)
await client.load()

# Start workflow
result = await client.start_workflow(
    workflow_args={"data": "test"},
    workflow_class=MyWorkflow
)

# Create worker
worker = client.create_worker(
    activities=[my_activity],
    workflow_classes=[MyWorkflow],
    passthrough_modules=["my_module"]
)
```

## Error Handling

### SQL Client
- Connection errors during `load()`
- Query execution errors in `run_query()`
- Resource cleanup in `close()`

### Temporal Client
- Connection errors during `load()`
- Workflow execution errors
- Worker creation errors
- Status retrieval errors

## Best Practices

1. Always use appropriate client type (sync/async) for your use case
2. Implement proper error handling
3. Clean up resources using `close()`
4. Use appropriate batch sizes for queries
5. Configure server-side cursors when appropriate
6. Handle workflow timeouts properly
7. Implement proper event tracking
8. Use appropriate worker configurations 